Linux Shell 通配符,元字符,转义符与正则表达式
===
## 通配符
字符 | 含义 | 实例
:---:|:---:|:---
`*` | 匹配 0 或多个字符 | a*b  a与b之间可以有任意长度的任意字符, 也可以一个也没有, 如aabcb, axyzb, a012b, ab。
`?` | 匹配任意一个字符 | a?b a与b之间必须也只能有一个字符, 可以是任意字符, 如aab, abb, acb, a0b。
`[list]` | 匹配 list 中的任意单一字符 | a[xyz]b   a与b之间必须也只能有一个字符, 但只能是 x 或 y 或 z, 如: axb, ayb, azb。
`[!list]` | 匹配 除list 中的任意单一字符 | a[!0-9]b  a与b之间必须也只能有一个字符, 但不能是阿拉伯数字, 如axb, aab, a-b。
`[c1-c2]` | 匹配 c1-c2 中的任意单一字符 如：[0-9] [a-z] | a[0-9]b  0与9之间必须也只能有一个字符 如a0b, a1b... a9b。
`{string1,string2,...}` | 匹配 sring1 或 string2 (或更多)其一字符串  | a{abc,xyz,123}b    a与b之间只能是abc或xyz或123这三个字符串之一。

## 元字符
字符 | 说明
:---:|:---
`IFS` | 由 `<space>` 或 `<tab>` 或 `<enter>` 三者之一组成(我们常用 space )。
`CR`  | 由 `<enter>` 产生。
`=` | 设定变量。
`$` | 作变量或运算替换(请不要与 shell prompt 搞混了)。
`>` | 重导向 stdout。 
`<` | 重导向 stdin。
`>>` | 重导向 stdout, 追加。 
`<<` | 重导向 stdin, 追加。
`|` | 命令管线。
反引号 | 两个反引号中间为可以先执行的指令 
`&` | 重导向 file descriptor ，或将命令置于背景执行。 
`( )` | 将其内的命令置于 nested subshell 执行，或用于运算或命令替换。(中间为子shell起始与结束) 
`[ ]` | 中间为字符组合
`{ }` | 将其内的命令置于 non-named function 中执行，或用在变量替换的界定范围。(中间为命令区块组合)
`;` | 在前一个命令结束时，而忽略其返回值，继续执行下一个命令。 
`&&` | 在前一个命令结束时，若返回值为 true(执行成功)，继续执行下一个命令。 
`||` | 在前一个命令结束时，若返回值为 false(执行失败)，继续执行下一个命令。 
`!` | 执行 history 列表中的命令。逻辑运算中的"非"(not)
`~` | 用户的根目录
`/` | 路径分隔符号
`#` | 注释

## 转义符
字符 | 说明
:---:|:---
`'(单引号)` | 又叫硬转义，其内部所有的shell 元字符、通配符都会被关掉。注意，硬转义中不允许出现’(单引号)。
`"(双引号)` | 又叫软转义，其内部只允许出现特定的shell 元字符：$用于参数代换 `用于命令代替
`\(反斜杠)` |    又叫转义，去除其后紧跟的元字符或通配符的特殊意义。

## 正则表达式
一个是基本正则表达式(`BRE`)，另一个是扩展正则表达式(`ERE`)。
如果没有明确指出的Meta字符，其将可同时用于BRE和ERE，否则将尽适用于指定的模式。

正则元字符 | 模式含义 | 用例
:---:|:---|:---
`\` | 通常用于关闭其后续字符的特殊意义，恢复其原意。 | \(...\)，这里的括号仅仅表示括号。
`.` | 匹配任何单个字符。 | a.b，将匹配abb、acb等
`*` | 匹配它之前的0-n个的单个字符。 | a*b，将匹配ab、aab、aaab等。
`^` | 匹配紧接着的正则表达式，在行的起始处。 | ^ab，将匹配abc、abd等，但是不匹配cab。
`$` | 匹配紧接着的正则表达式，在行的结尾处。 | ab$，将匹配ab、cab等，但是不匹配abc。
`[...]` | 方括号表达式，匹配其内部任何字符。其中-表示连续字符的范围，^符号置于方括号里第一个字符则有反向的含义，即匹配不在列表内(方括号)的任何字符。如果想让]和-表示其原意，需要将其放置在方括号的首字符位置，如[]ab]或[-ab]，如这两个字符同时存在，则将]放置在首字符位置，-放置在最尾部，如[]ab-]。 | [a-bA-Z0-9!]表示所有的大小写字母，数字和感叹号。[^abc]表示a、b、c之外的所有字符。[Tt]om，可以匹配Tom和tom。
`\{n,m\}` | 区间表达式，匹配在它前面的单个字符重复出现的次数区间，`\{n\}`表示重复n次；\{n,\}`表示至少重复n次；\{n,m\}`表示重复n到m次。 | `ab\{2\}`表示abb；`ab\{2,\}`表示abb、abbb等。`ab\{2,4\}`表示abb、abbb和abbbb。
`\(...\)` | 将圆括号之间的模式存储在特殊“保留空间”。最多可以将9个独立的子模式存储在单个模式中。匹配于子模式的文本，可以通过转义序列\1到\9，被重复使用在相同模式里。 `\(ab\)` |.*\1表示ab组合出现两次，两次之间可存在任何数目的任何字符，如abcdab、abab等。
`{n,m}(ERE)` | 其功能等同于上面的`\{n,m\}`，只是不再写\转义符了。 | ab+匹配ab、abbb等，但是不匹配a。
`+(ERE)` | 和前面的星号相比，+匹配的是前面正则表达式的1-n个实例。  
`?(ERE)` | 匹配前面正则表达式的0个或1个。 | ab?仅匹配a或ab。
`|(ERE)` | 匹配于|符号前后的正则表达式。 | (ab|cd)匹配ab或cd。
`[:alpha:]` | 匹配字母字符。 | [[:alpha:]!]ab$匹配cab、dab和!ab。
`[:alnum:]` | 匹配字母和数字字符。| [[:alnum:]]ab$匹配1ab、aab。
`[:blank:]` | 匹配空格(space)和Tab字符。
`[:cntrl:]` | 匹配控制字符。  
`[:digit:]` | 匹配数字字符。  
`[:graph:]` | 匹配非空格字符。   
`[:lower:]` | 匹配小写字母字符。  
`[:upper:]` | 匹配大写字母字符。  
`[:punct:]` | 匹配标点字符。  
`[:space:]` | 匹配空白(whitespace)字符。  
`[:xdigit:]` | 匹配十六进制数字。  
`\w` | 匹配任何字母和数字组成的字符，等同于[[:alnum:]_]   
`\W` | 匹配任何非字母和数字组成的字符，等同于[^[:alnum:]_]   
`\<\>` | 匹配单词的起始和结尾。 `\<read匹配readme，me\>`匹配readme。

**Linux Shell中常用的工具或命令分别支持的正则表达式的类型**

  | grep | sed | vi | egrep | awk
:---:|:---:|:---:|:---:|:---:
BRE | * | * | * |   | 
ERE |   |   |   | * | *
