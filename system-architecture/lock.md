Lock 锁
===

- 偏向锁：通过偏向提高性能（没有竞争的场合），竞争激烈的场合会增加系统负担，对象头标记为偏向，并将线程ID写入对象头Mark，只要没有竞争在将来进入同步块不需要同步，其他线程请求相同的锁时，偏向模式结束。
- 轻量级锁：将对象头的Mark指针保存到锁对象总，将对象头设置为指向锁的指针（在线程栈空间中），如果轻量级锁失败升级为重量级锁，没有锁竞争的前提下，减少传统锁使用OS互斥量产生的性能损耗，竞争激烈时，轻量级锁会多做很多额外操作，导致性能下降
- 自旋锁：竞争存在时，如果线程可以很快获得锁，那么可以不在OS层挂起线程，让线程做几个空操作（自旋），如果同步块很长自旋失败会降低系统性能，否则节省线程挂起切换时间，提升系统性能

**锁步骤**：
**偏向锁会先尝试偏向锁，轻量级锁会先尝试轻量级锁，以上都失败，尝试自旋锁，再失败，尝试普通锁，使用OS互斥量在操作系统层挂起。**

减少锁持有时间，持有时间长，自旋容易失败。

减小锁粒度（将大对象拆成小对象，增加并行度，降低锁竞争）。使用`ConcurrentHashMap AtomicLong`

锁粗化：在短时间内频繁对同一个锁上锁解锁会消耗系统资源，根据具体情况需要增加锁粒度进行锁粗化。

锁消除：即时编译器时，如果发现不可能被共享的对象，则可以消除这些对象的锁操作。

无锁：无锁是乐观的操作。
无锁的一种实现方式：
- CAS（Compare And Swap）
- 非阻塞同步
- 在应用层面判断多线程的干扰，如果有干扰，则通知线程重试。
- voliate 表示它所修饰的变量不保留拷贝，直接访问主内存中的对象
- AtomicInteger：原子方式更新